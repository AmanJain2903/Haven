import os
import hashlib
from typing import List
from fastapi import APIRouter, Depends, Response, HTTPException
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
from sqlalchemy import desc, case
from app.core.database import get_db
from app.core.config import settings
from app import models

router = APIRouter()
backend_url = settings.HOST_URL

@router.get("/", response_model=List[dict])
def get_videos(response: Response, skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Fetch a list of videos to display in the grid.
    """
    # FORCE NO CACHE
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "0"

    # Query the Video model
    videos = db.query(models.Video).offset(skip).limit(limit).all()

    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    return [
        {
            "id": vid.id,
            "filename": vid.filename,
            "is_favorite": vid.is_favorite,
            # Thumbnails for videos are usually JPGs generated by the processor
            "thumbnail_url": f"{backend_url}/api/v1/videos/thumbnail/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "preview_url": f"{backend_url}/api/v1/videos/preview/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "video_url": f"{backend_url}/api/v1/videos/file/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "date": vid.capture_date,
            "duration": vid.duration,
            "latitude": vid.latitude,
            "longitude": vid.longitude,
            "city": vid.city,
            "state": vid.state,
            "country": vid.country,
            "metadata": {
                "codec": vid.codec,
                "camera_make": vid.camera_make,
                "camera_model": vid.camera_model,
                "size_bytes": vid.file_size,
                "fps": vid.fps,             # Video specific metadata
                "width": vid.width,
                "height": vid.height,
            }
        }
        for vid in videos
    ]

@router.get("/details/{video_id}", response_model=dict)
def get_video_details(video_id: int, db: Session = Depends(get_db)):
    """
    Fetch detailed info for a specific video by ID.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    
    if not vid:
        raise HTTPException(status_code=404, detail="Video not found")
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    return {
        "id": vid.id,
        "filename": vid.filename,
        "is_favorite": vid.is_favorite,
        "thumbnail_url": f"{backend_url}/api/v1/videos/thumbnail/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
        "preview_url": f"{backend_url}/api/v1/videos/preview/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
        "video_url": f"{backend_url}/api/v1/videos/file/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
        "date": vid.capture_date,
        "duration": vid.duration,
        "latitude": vid.latitude,
        "longitude": vid.longitude,
        "city": vid.city,
        "state": vid.state,
        "country": vid.country,
        "metadata": {
            "codec": vid.codec,
            "camera_make": vid.camera_make,
            "camera_model": vid.camera_model,
            "size_bytes": vid.file_size,
            "fps": vid.fps,
            "width": vid.width,
            "height": vid.height
        }
    }

@router.get("/file/{video_id}")
def get_video_file(video_id: int, db: Session = Depends(get_db)):
    """
    Serve the actual video file.
    Note: FileResponse automatically handles Range requests (seeking) for modern browsers.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    
    if not vid:
        raise HTTPException(status_code=404, detail="Video not found")
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    # Assuming videos are stored in a 'videos' folder
    filePath = os.path.join(config.value, 'videos', vid.filename)
    
    if not os.path.exists(filePath):
         raise HTTPException(status_code=404, detail="File on disk not found")

    # Serve the file directly. No HEIC conversion needed for videos.
    return FileResponse(filePath)

@router.get("/preview/{video_id}")
def get_preview_file(video_id: int, db: Session = Depends(get_db)):
    """
    Serve the web-optimized preview version of the video (e.g., lower res MP4).
    If preview doesn't exist, fall back to the original file.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    if not vid:
        raise HTTPException(status_code=404)
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
        
    # 1. Check for pre-generated preview file (e.g. preview_HASH.mp4)
    path_hash = hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()
    # Assuming the processor generates previews with .mp4 extension
    preview_filename = f"preview_{path_hash}.mp4" 
    preview_path = os.path.join(settings.VIDEO_PREVIEW_DIR, preview_filename)
    
    if os.path.exists(preview_path):
        return FileResponse(preview_path)
    
    # 2. Fallback: Serve original
    filePath = os.path.join(config.value, 'videos', vid.filename)
    return FileResponse(filePath)

@router.get("/thumbnail/{video_id}")
def get_thumbnail_file(video_id: int, db: Session = Depends(get_db)):
    """
    Serve the JPG thumbnail for the video.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    if not vid:
        raise HTTPException(status_code=404)
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
        
    # Construct expected thumbnail path (Video thumbnails are usually .jpg)
    path_hash = hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()
    thumb_filename = f"thumb_{path_hash}.jpg"
    thumb_path = os.path.join(settings.VIDEO_THUMBNAIL_DIR, thumb_filename)
    
    if os.path.exists(thumb_path):
        return FileResponse(thumb_path)
    
    # Fallback: We can't easily serve the video as an image, 
    # so we might return a 404 or a default placeholder here.
    # For now, 404 is safer than trying to serve a 1GB video as an image source.
    raise HTTPException(status_code=404, detail="Thumbnail not found")

@router.get("/timeline", response_model=List[dict])
def get_timeline(
    response: Response,
    skip: int = 0, 
    limit: int = 500,
    db: Session = Depends(get_db)
):
    # FORCE NO CACHE 
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"

    total_count = db.query(models.Video).count()
    response.headers["X-Total-Count"] = str(total_count)
    
    videos = db.query(models.Video).order_by(
        case(
            (models.Video.capture_date != None, 0),
            else_=1
        ),
        desc(models.Video.capture_date),
        desc(models.Video.id)
    ).offset(skip).limit(limit).all()

    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    return [
        {
            "id": vid.id,
            "filename": vid.filename,
            "is_favorite": vid.is_favorite,
            "thumbnail_url": f"{backend_url}/api/v1/videos/thumbnail/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "preview_url": f"{backend_url}/api/v1/videos/preview/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "video_url": f"{backend_url}/api/v1/videos/file/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "date": vid.capture_date,
            "duration": vid.duration,
            "latitude": vid.latitude,
            "longitude": vid.longitude,
            "city": vid.city,
            "state": vid.state,
            "country": vid.country,
             "metadata": {
                "codec": vid.codec,
                "camera_make": vid.camera_make,
                "camera_model": vid.camera_model,
                "size_bytes": vid.file_size,
                "fps": vid.fps,
                "width": vid.width,
                "height": vid.height,
            }
        }
        for vid in videos
    ]
