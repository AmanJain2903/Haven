import os
import hashlib
from typing import List
from fastapi import APIRouter, Depends, Response, HTTPException
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
from sqlalchemy import desc, case
from app.core.database import get_db
from app.core.config import settings
from app import models

router = APIRouter()
backend_url = settings.HOST_URL

@router.get("/", response_model=List[dict])
def get_videos(response: Response, skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Fetch a list of videos to display in the grid.
    """
    # FORCE NO CACHE
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "0"

    # Query the Video model
    videos = db.query(models.Video).offset(skip).limit(limit).all()

    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    return [
        {
            "id": vid.id,
            "filename": vid.filename,
            "is_favorite": vid.is_favorite,
            # Thumbnails for videos are usually JPGs generated by the processor
            "thumbnail_url": f"{backend_url}/api/v1/videos/thumbnail/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "preview_url": f"{backend_url}/api/v1/videos/preview/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "video_url": f"{backend_url}/api/v1/videos/file/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "date": vid.capture_date,
            "duration": vid.duration,
            "latitude": vid.latitude,
            "longitude": vid.longitude,
            "city": vid.city,
            "state": vid.state,
            "country": vid.country,
            "metadata": {
                "codec": vid.codec,
                "camera_make": vid.camera_make,
                "camera_model": vid.camera_model,
                "size_bytes": vid.file_size,
                "fps": vid.fps,             # Video specific metadata
                "width": vid.width,
                "height": vid.height,
            }
        }
        for vid in videos
    ]

@router.get("/details/{video_id}", response_model=dict)
def get_video_details(video_id: int, db: Session = Depends(get_db)):
    """
    Fetch detailed info for a specific video by ID.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    
    if not vid:
        raise HTTPException(status_code=404, detail="Video not found")
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    return {
        "id": vid.id,
        "filename": vid.filename,
        "is_favorite": vid.is_favorite,
        "thumbnail_url": f"{backend_url}/api/v1/videos/thumbnail/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
        "preview_url": f"{backend_url}/api/v1/videos/preview/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
        "video_url": f"{backend_url}/api/v1/videos/file/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
        "date": vid.capture_date,
        "duration": vid.duration,
        "latitude": vid.latitude,
        "longitude": vid.longitude,
        "city": vid.city,
        "state": vid.state,
        "country": vid.country,
        "metadata": {
            "codec": vid.codec,
            "camera_make": vid.camera_make,
            "camera_model": vid.camera_model,
            "size_bytes": vid.file_size,
            "fps": vid.fps,
            "width": vid.width,
            "height": vid.height
        }
    }

@router.get("/file/{video_id}")
def get_video_file(video_id: int, db: Session = Depends(get_db)):
    """
    Serve the actual video file.
    Note: FileResponse automatically handles Range requests (seeking) for modern browsers.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    
    if not vid:
        raise HTTPException(status_code=404, detail="Video not found")
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    # Assuming videos are stored in a 'videos' folder
    filePath = os.path.join(config.value, 'videos', vid.filename)
    
    if not os.path.exists(filePath):
         raise HTTPException(status_code=404, detail="File on disk not found")

    # Serve the file directly with download headers
    response = FileResponse(
        filePath,
        media_type="application/octet-stream",
        filename=vid.filename
    )
    response.headers["Access-Control-Allow-Origin"] = "*"
    response.headers["Access-Control-Allow-Methods"] = "GET, OPTIONS"
    response.headers["Access-Control-Allow-Headers"] = "*"
    response.headers["Content-Disposition"] = f'attachment; filename="{vid.filename}"'
    return response

@router.get("/preview/{video_id}")
def get_preview_file(video_id: int, db: Session = Depends(get_db)):
    """
    Serve the web-optimized preview version of the video (e.g., lower res MP4).
    If preview doesn't exist, fall back to the original file.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    if not vid:
        raise HTTPException(status_code=404)
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
        
    # 1. Check for pre-generated preview file (e.g. preview_HASH.mp4)
    path_hash = hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()
    # Assuming the processor generates previews with .mp4 extension
    preview_filename = f"preview_{path_hash}.mp4" 
    preview_path = os.path.join(settings.VIDEO_PREVIEW_DIR, preview_filename)
    
    if os.path.exists(preview_path):
        return FileResponse(preview_path)
    
    # 2. Fallback: Serve original
    filePath = os.path.join(config.value, 'videos', vid.filename)
    return FileResponse(filePath)

@router.get("/thumbnail/{video_id}")
def get_thumbnail_file(video_id: int, db: Session = Depends(get_db)):
    """
    Serve the JPG thumbnail for the video.
    """
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    if not vid:
        raise HTTPException(status_code=404)
    
    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
        
    # Construct expected thumbnail path (Video thumbnails are usually .jpg)
    path_hash = hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()
    thumb_filename = f"thumb_{path_hash}.jpg"
    thumb_path = os.path.join(settings.VIDEO_THUMBNAIL_DIR, thumb_filename)
    
    if os.path.exists(thumb_path):
        return FileResponse(thumb_path)
    
    # Fallback: We can't easily serve the video as an image, 
    # so we might return a 404 or a default placeholder here.
    # For now, 404 is safer than trying to serve a 1GB video as an image source.
    raise HTTPException(status_code=404, detail="Thumbnail not found")

@router.get("/timeline", response_model=List[dict])
def get_timeline(
    response: Response,
    skip: int = 0, 
    limit: int = 500,
    db: Session = Depends(get_db)
):
    # FORCE NO CACHE 
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"

    total_count = db.query(models.Video).count()
    response.headers["X-Total-Count"] = str(total_count)
    
    videos = db.query(models.Video).order_by(
        case(
            (models.Video.capture_date != None, 0),
            else_=1
        ),
        desc(models.Video.capture_date),
        desc(models.Video.id)
    ).offset(skip).limit(limit).all()

    config = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    if not config or not config.value:
        raise HTTPException(status_code=503, detail="Storage not configured")
    
    return [
        {
            "id": vid.id,
            "filename": vid.filename,
            "is_favorite": vid.is_favorite,
            "thumbnail_url": f"{backend_url}/api/v1/videos/thumbnail/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "preview_url": f"{backend_url}/api/v1/videos/preview/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "video_url": f"{backend_url}/api/v1/videos/file/{vid.id}?h={hashlib.md5(os.path.join(config.value, 'videos', vid.filename).encode('utf-8')).hexdigest()}",
            "date": vid.capture_date,
            "duration": vid.duration,
            "latitude": vid.latitude,
            "longitude": vid.longitude,
            "city": vid.city,
            "state": vid.state,
            "country": vid.country,
             "metadata": {
                "codec": vid.codec,
                "camera_make": vid.camera_make,
                "camera_model": vid.camera_model,
                "size_bytes": vid.file_size,
                "fps": vid.fps,
                "width": vid.width,
                "height": vid.height,
            }
        }
        for vid in videos
    ]

@router.delete("/delete/{video_id}")
def delete_video(video_id: int, db: Session = Depends(get_db)):
    """
    Delete a video file from both cold storage and hot storage (thumbnails & previews), then remove from database.
    Also removes the video from any albums it's part of.
    """
    # 1. Get the video from database
    vid = db.query(models.Video).filter(models.Video.id == video_id).first()
    if not vid:
        raise HTTPException(status_code=404, detail="Video not found")
    
    # 2. Remove from all albums first
    albums = db.query(models.Albums).filter(models.Albums.album_videos_ids.contains([video_id])).all()
    for album in albums:
        # Remove this video ID from the array
        album.album_videos_ids = [vid_id for vid_id in album.album_videos_ids if vid_id != video_id]
        album.album_videos_count -=1
        album.album_total_count -=1
        # If this was the cover, clear it
        if album.album_cover_type == 'video' and album.album_cover_id == video_id:
            album.album_cover_type = None
            album.album_cover_id = None
    db.commit()
    
    # 3. Get storage paths
    cold_storage = db.query(models.SystemConfig).filter_by(key="storage_path").first()
    hot_storage = settings.APP_DATA_DIR
    
    if not cold_storage or not cold_storage.value:
        raise HTTPException(status_code=503, detail="Cold storage path not configured")
    if not hot_storage:
        raise HTTPException(status_code=503, detail="Hot storage path not configured")
    
    # 4. Delete original file from cold storage (storagePath/videos/)
    cold_file_path = os.path.join(cold_storage.value, 'videos', vid.filename)
    if os.path.exists(cold_file_path):
        try:
            os.remove(cold_file_path)
            print(f"Deleted cold storage file: {cold_file_path}")
        except Exception as e:
            print(f"Error deleting cold storage file: {e}")
            raise HTTPException(status_code=500, detail=f"Failed to delete original file: {str(e)}")
    
    # 5. Delete hot storage files (thumbnails and previews)
    # Thumbnails are named: thumb_{hash}.jpg
    # Previews are named: preview_{hash}.mp4
    path_hash = hashlib.md5(cold_file_path.encode('utf-8')).hexdigest()
    thumb_filename = f"thumb_{path_hash}.jpg"
    preview_filename = f"preview_{path_hash}.mp4"
    
    thumbnail_dir = os.path.join(hot_storage, "video_thumbnails")
    preview_dir = os.path.join(hot_storage, "video_previews")
    
    thumb_path = os.path.join(thumbnail_dir, thumb_filename)
    preview_path = os.path.join(preview_dir, preview_filename)
    
    # Delete thumbnail
    if os.path.exists(thumb_path):
        try:
            os.remove(thumb_path)
            print(f"Deleted thumbnail: {thumb_path}")
        except Exception as e:
            print(f"Error deleting thumbnail: {e}")
    
    # Delete preview
    if os.path.exists(preview_path):
        try:
            os.remove(preview_path)
            print(f"Deleted preview: {preview_path}")
        except Exception as e:
            print(f"Error deleting preview: {e}")
    
    # 6. Delete from database
    try:
        db.delete(vid)
        db.commit()
        print(f"Deleted video from database: {vid.filename}")
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to delete from database: {str(e)}")
    
    return {"success": True, "message": f"Video {vid.filename} deleted successfully"}
